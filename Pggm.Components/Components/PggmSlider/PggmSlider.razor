@* // The PGGM Slider component needs some investigation as it does not
// seem to fully support two-way binding out of the box. *@

@inherits PggmEventComponentBase
@namespace Pggm.Components


<pggm-slider @ref="ElementRef" @attributes="GetAttributes()">
  @ChildContent
</pggm-slider>

@code {
  public override string TagName => "pggm-slider";

  /// <summary>
  /// The current value of the slider
  /// </summary>
  [Parameter] public double Value { get; set; }

  /// <summary>
  /// The minimum value of the slider
  /// </summary>
  [Parameter] public double Min { get; set; } = 0;

  /// <summary>
  /// The maximum value of the slider
  /// </summary>
  [Parameter] public double Max { get; set; } = 100;

  /// <summary>
  /// Whether the slider is disabled
  /// </summary>
  [Parameter] public bool Disabled { get; set; }

  /// <summary>
  /// Comma-separated string of numbers that the slider should snap to
  /// </summary>
  [Parameter] public string? SnapValues { get; set; }

  /// <summary>
  /// Number of decimal places to display in the slider value (0 for integers)
  /// </summary>
  [Parameter] public int? FractionDigits { get; set; }

  /// <summary>
  /// Event callback for when the slider value changes
  /// </summary>
  [Parameter] public EventCallback<double> ValueChanged { get; set; }

  /// <summary>
  /// Event callback for the input event (continuous updates while dragging)
  /// </summary>
  [Parameter] public EventCallback<double> OnInput { get; set; }

  protected override IEnumerable<string> GetEventNames()
  {
    yield return Constants.EventNames.Change;
    yield return Constants.EventNames.Input;
  }

  protected override Dictionary<string, Func<object?, Task>> EventHandlers => new()
  {
    { Constants.EventNames.Change, HandleValueChangeAsync },
    { Constants.EventNames.Input, HandleInputAsync }
  };

  private async Task HandleValueChangeAsync(object? eventData)
  {
    await UpdateValueFromElement();
    
    if (ValueChanged.HasDelegate)
    {
      await ValueChanged.InvokeAsync(Value);
    }
  }

  private async Task HandleInputAsync(object? eventData)
  {
    await UpdateValueFromElement();
    
    if (OnInput.HasDelegate)
    {
      await OnInput.InvokeAsync(Value);
    }
  }

  private async Task UpdateValueFromElement()
  {
    try
    {
      var newValue = await JSRuntime.InvokeAsync<double>("PggmComponents.getProperty", ElementRef, "value");
      
      if (Math.Abs(Value - newValue) > double.Epsilon)
      {
        Value = newValue;
        await InvokeAsync(StateHasChanged);
      }
    }
    catch (Exception ex)
    {
      Console.WriteLine($"Error updating slider value: {ex.Message}");
    }
  }

  protected override void AddComponentAttributes(Dictionary<string, object> attributes)
  {
    attributes["value"] = Value;
    attributes["min"] = Min;
    attributes["max"] = Max;
    
    AttributeHelper.SetBooleanAttribute(attributes, Constants.AttributeNames.Disabled, Disabled);
    
    if (!string.IsNullOrWhiteSpace(SnapValues))
    {
      attributes[Constants.AttributeNames.SnapValues] = SnapValues;
      AttributeHelper.SetBooleanAttribute(attributes, Constants.AttributeNames.EnableSnap, true);
    }
    
    if (FractionDigits.HasValue)
    {
      attributes[Constants.AttributeNames.FractionDigits] = FractionDigits.Value;
    }
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    await base.OnAfterRenderAsync(firstRender);
  }

  protected override async Task OnParametersSetAsync()
  {
    await base.OnParametersSetAsync();
    
    // Update the element value if it was changed externally
    if (ElementRef.Id != null)
    {
      try
      {
        await JSRuntime.InvokeVoidAsync("PggmComponents.setProperty", ElementRef, "value", Value);
      }
      catch
      {
        // Element might not be ready yet, ignore
      }
    }
  }
}
