@using System.Text.Json
@inherits PggmEventComponentBase
@namespace Pggm.Components

<select is="pggm-select" @ref="ElementRef" value="@Value" @onchange="HandleValueChanged" @attributes="GetAttributes()">
  @ChildContent
</select>

@code {
  protected override string TagName => "select";

  /// <summary>
  /// The currently selected value
  /// </summary>
  [Parameter] public string? Value { get; set; }

  /// <summary>
  /// Event callback for when the selected value changes (two-way binding)
  /// </summary>
  [Parameter] 
  public EventCallback<string?> ValueChanged { get; set; }

  /// <summary>
  /// Handle value changes and invoke callbacks
  /// </summary>
  private async Task HandleValueChanged(ChangeEventArgs args)
  {
    var newValue = args.Value?.ToString();
    
    if (Value != newValue)
    {
      Value = newValue;
      
      if (ValueChanged.HasDelegate)
      {
        await ValueChanged.InvokeAsync(newValue);
      }
      
      if (OnChange.HasDelegate)
      {
        await OnChange.InvokeAsync(args);
      }
    }
  }

  /// <summary>
  /// Whether the select is disabled
  /// </summary>
  [Parameter] public bool Disabled { get; set; }

  /// <summary>
  /// Whether the select is required
  /// </summary>
  [Parameter] public bool Required { get; set; }

  /// <summary>
  /// The name attribute for the select
  /// </summary>
  [Parameter] public string? Name { get; set; }

  /// <summary>
  /// Whether multiple selections are allowed
  /// </summary>
  [Parameter] public bool Multiple { get; set; }

  /// <summary>
  /// The size attribute (number of visible options)
  /// </summary>
  [Parameter] public int? Size { get; set; }

  /// <summary>
  /// Auto-focus the select when the page loads
  /// </summary>
  [Parameter] public bool AutoFocus { get; set; }

  /// <summary>
  /// The form attribute (associates with a form)
  /// </summary>
  [Parameter] public string? Form { get; set; }

  /// <summary>
  /// Event callback for the change event
  /// </summary>
  [Parameter] public EventCallback<ChangeEventArgs> OnChange { get; set; }

  /// <summary>
  /// Event callback for the focus event
  /// </summary>
  [Parameter] public EventCallback<FocusEventArgs> OnFocus { get; set; }

  /// <summary>
  /// Event callback for the blur event
  /// </summary>
  [Parameter] public EventCallback<FocusEventArgs> OnBlur { get; set; }

  protected override Dictionary<string, Func<object?, Task>> EventHandlers => new()
  {
    ["focus"] = HandleFocusEventAsync,
    ["blur"] = HandleBlurEventAsync
  };

  protected override IEnumerable<string> GetEventNames()
  {
    return new[] { "focus", "blur" };
  }

  private async Task HandleFocusEventAsync(object? eventData)
  {
    if (OnFocus.HasDelegate)
    {
      await InvokeAsync(async () =>
      {
        var focusArgs = new FocusEventArgs();
        await OnFocus.InvokeAsync(focusArgs);
      });
    }
  }

  private async Task HandleBlurEventAsync(object? eventData)
  {
    if (OnBlur.HasDelegate)
    {
      await InvokeAsync(async () =>
      {
        var focusArgs = new FocusEventArgs();
        await OnBlur.InvokeAsync(focusArgs);
      });
    }
  }

  protected override void AddComponentAttributes(Dictionary<string, object> attributes)
  {
    AttributeHelper.SetBooleanAttribute(attributes, Constants.AttributeNames.Disabled, Disabled);
    AttributeHelper.SetBooleanAttribute(attributes, Constants.AttributeNames.Required, Required);
    AttributeHelper.SetBooleanAttribute(attributes, "multiple", Multiple);
    AttributeHelper.SetBooleanAttribute(attributes, "autofocus", AutoFocus);
    AttributeHelper.SetAttributeIfNotEmpty(attributes, Constants.AttributeNames.Name, Name);
    AttributeHelper.SetAttributeIfNotEmpty(attributes, Constants.AttributeNames.Value, Value);
    AttributeHelper.SetAttributeIfNotEmpty(attributes, "form", Form);
    
    if (Size.HasValue)
    {
      attributes["size"] = Size.Value;
    }
  }
}